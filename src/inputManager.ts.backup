import * as THREE from "three";

// Lightweight on-screen joystick used for touch controls.
class VirtualJoystick {
  private container: HTMLDivElement;
  private base: HTMLDivElement;
  private knob: HTMLDivElement;
  private pointerId: number | null = null;
  private value = new THREE.Vector2();
  private readonly radius = 60; // visual radius (px)
  private globalPointermoveListener: (e: PointerEvent) => void;
  private globalPointerupListener: (e: PointerEvent) => void;
  private centerX: number = 0;
  private centerY: number = 0;
  private joystickPointerIds: Set<number>;

  constructor(position: "left" | "right", joystickPointerIds: Set<number>) {
    this.joystickPointerIds = joystickPointerIds;
    this.container = document.createElement("div");
    this.container.className = `joystick-container ${position}`;

    this.base = document.createElement("div");
    this.base.className = "joystick-base";

    this.knob = document.createElement("div");
    this.knob.className = "joystick-knob";

    this.base.appendChild(this.knob);
    this.container.appendChild(this.base);
    document.body.appendChild(this.container);

    // Prevent joystick touches from interacting with the world.
    const stopEvent = (e: Event) => {
      e.preventDefault();
      e.stopPropagation();
    };

    // Create global listeners that will be attached to document
    this.globalPointermoveListener = (e: PointerEvent) => {
      if (this.pointerId === null || this.pointerId !== e.pointerId) return;
      stopEvent(e);
      this.updateValue(e);
    };

    this.globalPointerupListener = (e: PointerEvent) => {
      if (this.pointerId === null || this.pointerId !== e.pointerId) return;
      stopEvent(e);
      this.reset();
    };

    this.base.addEventListener("pointerdown", (e) => {
      if (this.pointerId !== null) return;
      const rect = this.base.getBoundingClientRect();
      this.centerX = rect.left + rect.width / 2;
      this.centerY = rect.top + rect.height / 2;
      this.pointerId = (e as PointerEvent).pointerId;
      this.joystickPointerIds.add(this.pointerId);
      stopEvent(e);
      this.updateValue(e as PointerEvent);

      // Attach global listeners when pointer is down
      document.addEventListener("pointermove", this.globalPointermoveListener);
      document.addEventListener("pointerup", this.globalPointerupListener);
      document.addEventListener("pointercancel", this.globalPointerupListener);
    });

    this.base.addEventListener("pointercancel", () => {
      if (this.pointerId !== null) {
        this.reset();
      }
    });
  }

  private reset() {
    if (this.pointerId !== null) {
      this.joystickPointerIds.delete(this.pointerId);
    }
    this.pointerId = null;
    this.value.set(0, 0);
    this.knob.style.left = `${this.radius}px`;
    this.knob.style.top = `${this.radius}px`;

    // Remove global listeners
    document.removeEventListener("pointermove", this.globalPointermoveListener);
    document.removeEventListener("pointerup", this.globalPointerupListener);
    document.removeEventListener("pointercancel", this.globalPointerupListener);
  }

  private updateValue(e: PointerEvent) {
    const dx = e.clientX - this.centerX;
    const dy = e.clientY - this.centerY;

    // Normalize to -1..1 range, invert Y so up is positive.
    const nx = THREE.MathUtils.clamp(dx / this.radius, -1, 1);
    const ny = THREE.MathUtils.clamp(-dy / this.radius, -1, 1);
    this.value.set(nx, ny);

    // Move knob visually within circle bounds.
    const len = Math.min(1, Math.hypot(nx, ny));
    const angle = Math.atan2(ny, nx);
    const knobX = this.radius + Math.cos(angle) * this.radius * len;
    const knobY = this.radius - Math.sin(angle) * this.radius * len;
    this.knob.style.left = `${knobX}px`;
    this.knob.style.top = `${knobY}px`;
  }

  public getValue(): THREE.Vector2 {
    return this.value.clone();
  }

  public isPointInside(clientX: number, clientY: number): boolean {
    const rect = this.base.getBoundingClientRect();
    return clientX >= rect.left && clientX <= rect.right &&
      clientY >= rect.top && clientY <= rect.bottom;
  }

  public dispose() {
    this.reset();
    this.container.remove();
  }
}

export class InputManager {
  private keys: Set<string> = new Set();
  private mouseDelta = new THREE.Vector2();
  private _mousePosition = new THREE.Vector2();
  private _lastMousePosition = new THREE.Vector2();
  private _lastTouchPosition = new THREE.Vector2();
  private touchDelta = new THREE.Vector2();
  private _activeTouchPointerId: number | null = null;
  private _lastTouchX = 0;
  private _lastTouchY = 0;

  private interactRequested = false;

  private joystickPointerIds = new Set<number>();
  private readonly leftJoystick = new VirtualJoystick(
    "left",
    this.joystickPointerIds,
  );
  private readonly rightJoystick = new VirtualJoystick(
    "right",
    this.joystickPointerIds,
  );

  private _handlers: Record<string, (e: Event) => void> = {};
  private _lastTouchDown: { clientX: number; clientY: number } | null = null;

  constructor() {
    this.setupHandlers();
    this.attach();
  }

  private setupHandlers() {
    this._handlers = {
      keydown: (e: Event) => {
        const key = (e as KeyboardEvent).key;
        this.keys.add(key);
        // Spacebar triggers interaction for keyboard play.
        if (key === " " || key === "Spacebar" || key === "Space") {
          this.queueInteract();
        }
        // ESC unlocks pointer for menu access
        if (key === "Escape") {
          document.exitPointerLock?.();
        }
      },
      keyup: (e: Event) => this.keys.delete((e as KeyboardEvent).key),
      mousedown: (_e: Event) => {
        // Request pointer lock for FPS mouse look on desktop (any button)
        if (!document.pointerLockElement) {
          document.body.requestPointerLock?.();
        }
      },
      mousemove: (e: Event) => {
        const me = e as MouseEvent;
        // Calculate position-based delta as fallback (when pointer lock unavailable)
        const newX = (me.clientX / globalThis.innerWidth) * 2 - 1;
        const newY = -(me.clientY / globalThis.innerHeight) * 2 + 1;
        const posDeltaX = newX - this._lastMousePosition.x;
        const posDeltaY = newY - this._lastMousePosition.y;
        this._lastMousePosition.set(newX, newY);

        // Store normalized position for raycasting
        this._mousePosition.set(newX, newY);
        this._lastTouchPosition.set(newX, newY);

        // Track delta for FPS camera: use movementX/Y when available (pointer locked),
        // otherwise use position delta as fallback.
        if (me.movementX !== 0 || me.movementY !== 0) {
          // Pointer is locked, use movement delta
          this.mouseDelta.x += me.movementX;
          this.mouseDelta.y += me.movementY;
        } else if (posDeltaX !== 0 || posDeltaY !== 0) {
          // Fallback: use position-based delta (scale to match sensitivity)
          this.mouseDelta.x += posDeltaX * 100;
          this.mouseDelta.y += posDeltaY * 100;
        }
      },
      pointerdown: (e: Event) => {
        const pe = e as PointerEvent;
        // Check if this is a touch or joystick event
        if (!this.isTouchOnJoystick(pe.clientX, pe.clientY)) {
          // Store the touch point for later use
          this._lastTouchDown = { clientX: pe.clientX, clientY: pe.clientY };
          // Start tracking this touch for swipe/look
          this._activeTouchPointerId = pe.pointerId;
          this._lastTouchX = pe.clientX;
          this._lastTouchY = pe.clientY;
        }
        // Track touch position for interactions
        this._lastTouchPosition.x = (pe.clientX / globalThis.innerWidth) * 2 -
          1;
        this._lastTouchPosition.y = -(pe.clientY / globalThis.innerHeight) * 2 +
          1;
      },
      pointermove: (e: Event) => {
        const pe = e as PointerEvent;
        // Track touch swipe for camera look if pointer is not from a joystick
        if (
          this._activeTouchPointerId === pe.pointerId &&
          !this.joystickPointerIds.has(pe.pointerId)
        ) {
          const deltaX = pe.clientX - this._lastTouchX;
          const deltaY = pe.clientY - this._lastTouchY;
          this.touchDelta.x += deltaX;
          this.touchDelta.y += deltaY;
          this._lastTouchX = pe.clientX;
          this._lastTouchY = pe.clientY;
        }
      },
      pointerup: (e: Event) => {
        const pe = e as PointerEvent;
        if (this._activeTouchPointerId === pe.pointerId) {
          this._activeTouchPointerId = null;
        }
      },
      pointercancel: (e: Event) => {
        const pe = e as PointerEvent;
        if (this._activeTouchPointerId === pe.pointerId) {
          this._activeTouchPointerId = null;
        }
      },
      contextmenu: (e: Event) => (e as MouseEvent).preventDefault(),
    };
  }

  private attach() {
    Object.entries(this._handlers).forEach(([evt, handler]) => {
      globalThis.addEventListener(evt, handler);
    });
  }

  public dispose() {
    Object.entries(this._handlers).forEach(([evt, handler]) => {
      globalThis.removeEventListener(evt, handler);
    });
    this.leftJoystick.dispose();
    this.rightJoystick.dispose();
  }

  // --- Public API ---

  public getLookDelta(): THREE.Vector2 {
    const delta = this.mouseDelta.clone();
    this.mouseDelta.set(0, 0); // Reset after reading

    // Add touch swipe contribution for look
    delta.x += this.touchDelta.x;
    delta.y += this.touchDelta.y;
    this.touchDelta.set(0, 0); // Reset after reading

    // Add right joystick contribution for touch look.
    const joy = this.rightJoystick.getValue();
    if (joy.lengthSq() > 0) {
      delta.x += joy.x * 25; // scale to match mouse sensitivity
      delta.y += joy.y * 25;
    }
    return delta;
  }

  public getNormalizedMousePosition(): THREE.Vector2 {
    return this._mousePosition.clone();
  }

  public isKeyDown(key: string): boolean {
    return this.keys.has(key);
  }

  // Helper to get -1 to 1 value for movement axes
  public getAxis(positiveKey: string, negativeKey: string): number {
    return (this.keys.has(positiveKey) ? 1 : 0) -
      (this.keys.has(negativeKey) ? 1 : 0);
  }

  public getMovementVector(): THREE.Vector2 {
    // Joystick has priority; falls back to keyboard for desktop play.
    const joy = this.leftJoystick.getValue();
    if (joy.lengthSq() > 0.0001) return joy.clone();

    const moveZ = this.getAxis("s", "w") ||
      this.getAxis("ArrowDown", "ArrowUp");
    const moveX = this.getAxis("d", "a") ||
      this.getAxis("ArrowRight", "ArrowLeft");
    return new THREE.Vector2(moveX, -moveZ); // y positive means forward like joystick
  }

  public consumeKey(key: string): boolean {
    if (this.keys.has(key)) {
      this.keys.delete(key);
      return true;
    }
    return false;
  }

  // Interaction queue: used by spacebar, mouse/tap, or on-screen button
  public queueInteract() {
    this.interactRequested = true;
  }

  public consumeInteractRequest(): boolean {
    const should = this.interactRequested;
    this.interactRequested = false;
    return should;
  }

  // Clears transient input state (used on level reset/game over).
  public clear() {
    this.keys.clear();
    this.mouseDelta.set(0, 0);
    this.touchDelta.set(0, 0);
    this.interactRequested = false;
  }

  // Check if a screen coordinate is within joystick bounds
  public isTouchOnJoystick(clientX: number, clientY: number): boolean {
    return this.leftJoystick.isPointInside(clientX, clientY) ||
      this.rightJoystick.isPointInside(clientX, clientY);
  }

  // Get the last touch/pointer position for cursor placement
  public getLastTouchPosition(): THREE.Vector2 {
    return this._lastTouchPosition.clone();
  }

  // Get the touch down position (screen coordinates) for marker placement
  public getLastTouchDownPoint(): { clientX: number; clientY: number } | null {
    return this._lastTouchDown;
  }

  // Clear the touch down point after handling it
  public clearTouchDownPoint(): void {
    this._lastTouchDown = null;
  }
}
